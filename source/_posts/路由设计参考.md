title: 路由设计参考
date: 2017-08-29 12:08:42
tags:
---

## 问题

业务原因需要调用一个touch系统的页面。因为是多页的，这个touch系统在后退的时候，会打开地址栏传递的url参数。而此时在我的栈式历史记录管理结构中，造成了一个`Home -> A -> B -> A`的循环，后退不回去。那么我在新打开的A中应该如何执行后退，一下子打开Home页面呢。注意一下所有的探索仅仅限于浏览器内，不考虑含有hybrid框架的app内。

### 方案一

利用浏览器历史记录的特性做了一个方案。如下：

```
	function getRealHistoryLength() {
		const rnd = Date().now()
		location.href = `#_h_seq_${rnd}`

		return history.length - 1
	}
```

在当前地址的基础之上，入栈一个从未出现过的历史记录，此时历史记录会被重置，此时求取历史记录的长度就是当前页面所在的历史记录中的index。通过这种技巧可以得知历史记录两个页面的差值，从而可以通过histroy.go()来精确的控制后退的步长。

不过理想很丰满，显示很骨感。

实际中发现，部分手机的浏览器在执行history.go的时候，只能执行-1，再所就后退不了了；还有部分手机干脆历史记录变得紊乱，不能取到争取的history.length的值。

哎😔，说起来都是泪。


## 继续探索

既然操作历史记录的方式不靠谱，那么能不能不后退，我干脆新打开呢`Home -> A -> B -> A -> Home`,那么此时的问题就是经过B的回调，整个历史记录的管理走向一个不归路，再也回不到起点了，历史记录越堆越长。

假设这种方式可行，那么还需要解决两个问题。

第一个问题： 我怎么知道A应该打开Home而不是其他页面，我需要用户访问的历史记录。根据实际生成的历史记录来决定应该如何走下一步。在sessionStorage里面存储用户打开过的所有页面历史，然后做一个虚拟的历史记录。
第二个问题： 通过虚拟的历史记录解决了应该跳转哪一个页面的问题，似乎一切都好转起来了，不过如果android用户使用了物理后退键呢？此时会触发浏览器自己的历史记录行为history.back()。借鉴方案一的思路，我们可以在每次打开页面之后，把当前的历史记录增加一个hash位。

```
	function putReturnMark() {
		location.href = `#_back_mk_${Date.now()}`
	}
	window.addEventListner('hashChange', ({oldURL}) => {
		if ( /_back_mk_/i.test(oldURL) ) {
			// 物理后退
			doSessionHistoryBack()
		}
	})
```

不过sessionStorage在隐私模式下无法使用。因此也不算一个很完美的解决方案。而且历史栈的管理也不是特别完美。

## 继续探索

借鉴方案二的back拦截方案，sessionStorage存储历史记录的方式。不过页面的历史记录切换钧采用replace的方案。这样比起方案二，历史记录总算不会没完没了的增长。

## 继续探索

当然最好的方案还是请求兄弟部门配合做下修改。不过这个又是得看运气了。



























